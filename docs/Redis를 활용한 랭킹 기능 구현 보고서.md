# Redis 기반 랭킹 기능 구현 보고서

## 1. Redis를 활용한 랭킹 기능 개발

이번 과제를 진행하면서 상품의 인기도(=주문 수량 기준)를 기준으로 **랭킹을 계산하고 노출하는 기능**을 구현하게 되었습니다. 처음에는 단순하게 DB 쿼리를 통해 특정 기간의 주문 데이터를 집계해서 정렬하려고 했지만, 아래와 같은 문제점들이 예상되었습니다.

* **사용자 수와 주문 데이터가 많아질수록 쿼리 성능이 급격히 저하**
* 매번 집계할 때마다 DB에 **부하가 발생하고, 실시간 응답이 어려움**
* 트래픽이 몰릴 경우 **랭킹 조회 요청으로 인해 전체 시스템에 영향 가능**

이러한 이유로 랭킹 데이터를 효율적으로 집계하고 조회하기 위해 Redis를 도입하게 되었습니다.
Redis는 빠른 조회 속도와 다양한 자료구조를 제공하므로, 랭킹과 같이 **정렬이 필요한 데이터에 적합한 환경**을 제공해줍니다.

---

## 2. Redis 도입 시 기대했던 효과와 검증

### 기대 효과 (가설)

* 실시간 집계 가능: 주문 발생 시마다 Redis에 바로 반영
* 빠른 조회 속도: 조회 시 DB 접근 없이 메모리에서 바로 반환
* 순위 기능 최적화: Redis의 ZSet은 score 기반으로 정렬이 자동 처리됨
* TTL을 통한 메모리 관리 및 자동 소멸 구조 가능

### 실제 검증 결과

* Redis ZSet을 사용해 주문 수량 기준으로 score를 누적했을 때, **삽입과 업데이트가 모두 O(log N)** 이내로 안정적이었고,
* ZUNIONSTORE를 통해 여러 일자 데이터를 합산할 때에도 **성능 저하 없이 즉시 계산 가능**
* 캐시를 활용함으로써 빈번한 요청에도 **조회 성능이 매우 안정적**이었음

---

## 3. 랭킹 집계 구조 및 ZSet 선택 이유

### 왜 ZSet인가?

Redis의 `ZSet`(Sorted Set)은 랭킹 기능 구현에 거의 최적화된 자료구조입니다.

| 특징    | 설명                              |
| ----- | ------------------------------- |
| 자동 정렬 | score 값을 기준으로 자동 정렬됨            |
| 중복 방지 | 동일 key에 대해 score만 갱신되므로 덮어쓰기 형태 |
| 범위 조회 | top-N 조회 또는 특정 score 범위 조회가 간편  |

### 장점

* 실시간 업데이트가 간편하고 성능이 좋음
* 별도 정렬 처리가 필요 없음 (삽입 시 자동 정렬)
* 사용자 수가 많아져도 조회 성능이 거의 일정하게 유지됨

### 단점 및 한계

* ZSet의 내부 자료구조는 skip list이므로 **메모리 사용량이 많음**
* 데이터가 많아질수록 TTL 없이 방치되면 **메모리 누수 위험이 있음**
* ZUNIONSTORE는 대상 키가 없을 경우 빈 결과가 반환됨 → **키 존재 여부 확인 필수**

---

## 4. 집계 및 조회 방식 설계

### 집계 방식

* **주문 발생 시점에 Redis ZSet에 score 누적**

  * key: `ranking:product:daily:{yyyyMMdd}`
  * member: productId
  * score: 누적 주문 수량

### 조회 방식

* 최근 3일 또는 7일, 30일 등 다양한 기간의 랭킹을 보여주기 위해,
* `ZUNIONSTORE` 명령을 사용하여 **여러 일자의 ZSet을 합산**하고,
* 그 결과를 **별도의 캐시 키에 저장**한 뒤 응답
* 이 캐시 키는 **5분마다 리프레시**되며, TTL이 만료되기 전에 갱신됨

예시:

```text
ZUNIONSTORE ranking:product:daily:cached
  3
  ranking:product:daily:20250515
  ranking:product:daily:20250514
  ranking:product:daily:20250513
```

---

## 5. TTL 설정 전략

### 왜 TTL을 설정했는가?

랭킹 데이터를 Redis에 무제한으로 쌓아두면, 시간이 지남에 따라 메모리가 계속 증가하게 됩니다. 이를 방지하고, 메모리 사용량을 적절히 관리하기 위해 **TTL(Time To Live)** 을 설정하였습니다.

### TTL 기준

* 현재 가장 긴 집계 주기가 **30일간 누적 데이터 조회 (월간 인기상품)** 이므로,
* 각 일별 ZSet(`ranking:product:daily:{yyyyMMdd}`)에는 **30일 TTL을 설정**
* 캐시된 조회 결과(`ranking:product:daily:cached`)는 **5분 TTL로 설정**, 정기적으로 리프레시

이로써 오래된 데이터는 자동으로 정리되며, 불필요한 메모리 점유를 방지할 수 있게 됩니다.

---

## 6. 예상 가능한 문제점

* **ZSet에 삽입되는 키 수가 많을 경우 메모리 사용량 증가**
* 캐시 리프레시 타이밍과 조회 요청이 겹치면 **캐시 미스가 발생할 수 있음**
* ZUNIONSTORE는 대상 키가 존재하지 않을 경우 빈 결과 반환 → **처리 로직에서 이 부분을 고려해야 함**
* 일별 데이터가 비정상적으로 누락되었을 경우 전체 집계에 영향을 줄 수 있음

---

## 7. 구조의 한계와 개선 방안

### 한계점

* 실시간 랭킹은 가능하지만, **동시에 많은 키를 집계할 경우 ZUNIONSTORE 연산 비용이 부담될 수 있음**
* 일자별 랭킹 키를 별도로 관리하다 보니, **키 관리 복잡도 증가**
* TTL 관리나 데이터 정합성 보장에 대한 별도의 모니터링 도구가 필요

### 개선 아이디어

* 일자별 데이터가 너무 많아질 경우, **주기적으로 RDB로 백업하여 Redis 메모리 부담 최소화**
* 랭킹 조회 API는 일정 수준 이상의 트래픽이 예상되므로 **API Gateway + 캐시 계층 추가 검토**
* ZUNIONSTORE 연산 결과도 Redis에 저장하고, 조회 요청은 이 캐시만 조회하도록 구조 단순화
* 장기적으로는 Kafka 기반으로 주문 이벤트를 수집하고, Redis에는 집계된 결과만 반영하는 구조로 개선 가능

---

## 8. 마무리하며

이번 과제를 통해 Redis를 활용한 랭킹 기능을 직접 설계하고 구현해보면서, 단순한 캐시 이상으로 Redis가 얼마나 다양한 역할을 할 수 있는지 체감할 수 있었습니다.

특히 ZSet 자료구조를 활용해 **랭킹 데이터를 자동 정렬하고 누적 처리**하는 방식은 성능 측면에서 매우 만족스러웠지만, 동시에 TTL 설정, 키 관리, 캐시 타이밍과 같은 실무적인 고민거리도 함께 경험할 수 있었습니다.

향후에는 트래픽 급증 상황에서도 안정적으로 랭킹 기능을 운영하기 위한 구조 개선 방안들(Kafka 연계, 모니터링, 캐시 계층 등)을 실험적으로 적용해보면서 구조를 더 단단하게 만들어볼 계획입니다.

---