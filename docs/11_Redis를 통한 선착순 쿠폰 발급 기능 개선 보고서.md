
# Redis를 활용한 선착순 쿠폰 발급 기능 개선 보고서

## 1. 개선을 시도하게 된 배경

이번 과제에서는 **선착순 쿠폰 발급 기능을 고도화**하는 미션을 수행하게 되었습니다. 초기에는 단순히 DB에 쿠폰 재고 정보를 저장하고, 발급 요청이 들어올 때마다 트랜잭션을 통해 재고를 차감하는 방식으로 구현했는데, 몇 가지 문제를 겪으면서 개선이 필요하다고 느꼈습니다.

* **트래픽이 몰릴 때 DB에 과부하가 걸리며 병목이 발생**
* **동시에 여러 사용자가 발급을 시도할 경우 동시성 이슈 발생 가능**
* 그리고 결정적으로, 선착순이라는 특성을 제대로 보장하기 어렵다는 점에서 구조적인 개선이 필요하다고 판단했습니다.

그래서 Redis를 활용해보면 어떨까 하는 방향으로 리팩토링을 시도하게 되었습니다.

---

## 2. Redis를 도입한 목적과 기대 효과

Redis는 메모리 기반의 고성능 저장소로, 빠른 응답 속도와 다양한 자료구조를 활용할 수 있다는 장점이 있습니다. Redis를 쿠폰 발급 처리에 도입하면 다음과 같은 기대 효과가 있었습니다.

* **중복 발급 여부를 빠르게 검증**할 수 있다. → Redis의 `Set`을 활용
* **사용자의 발급 요청 순서를 보장**할 수 있다. → Redis의 `ZSet`을 활용
* DB 대신 Redis에서 선필터링을 하고, 발급 가능한 요청만 처리하는 구조를 만들면 **DB 부하를 줄일 수 있다**
* 발급 처리를 **비동기화**함으로써 사용자에게는 빠르게 응답하고, 실제 처리는 나중에 안정적으로 수행할 수 있다

이러한 구조를 바탕으로 몇 가지 설계 방식을 실험해봤습니다.

---

## 3. Redis를 활용한 개선 시도

### 방법 1 - Redis를 "DB처럼" 사용하는 구조

처음에는 Redis에 쿠폰 재고와 발급 유저 목록을 저장하고, Lua 스크립트를 통해 다음을 하나의 연산으로 처리해봤습니다.

* 재고 차감
* 중복 발급 여부 확인
* 발급 유저로 등록

이 방식은 빠르고 원자적으로 처리된다는 장점은 있었지만, 다음과 같은 문제점이 드러났습니다.

* Redis는 **트랜잭션과 영속성이 보장되지 않기 때문에**, 예기치 않은 장애 상황에서 데이터 정합성이 깨질 수 있음
* Redis와 DB 간의 동기화 실패가 발생할 경우, **실제와 다른 쿠폰 발급 상태가 만들어질 수 있음**
* 결국 Redis에 너무 많은 책임을 지우는 구조가 되어버림

이 구조는 성능 면에서는 훌륭했지만, 안정성과 복잡도 측면에서 실무에서 사용하기엔 부담이 컸습니다.

---

### 방법 2 - Redis는 검증과 큐잉 역할만 수행

두 번째 방법에서는 Redis를 **검증과 큐잉 역할에만 집중**시키고, 최종 발급 결과는 DB에서 관리하는 구조로 리팩토링했습니다.

#### 흐름 요약

1. **발급 요청 시점**

    * Redis `Set`을 통해 **중복 발급 여부 확인**
    * Redis `ZSet`을 통해 **요청을 큐에 적재 (요청 순서 보장)**
    * Redis `List`에 해당 쿠폰 ID를 추가하여, 처리 대상임을 표시

2. **발급 처리 (배치 프로세스)**

    * 1초 간격으로 실행되는 **싱글 스레드 배치 프로세스**가 큐를 확인
    * 쿠폰 최대 수량과 현재까지 발급된 유저 수를 기준으로 발급 가능한 수량 계산
    * Redis에서 유효한 요청을 꺼내 DB에 저장 (실제 발급 처리)
    * 이 때도 **중복 검증을 다시 수행** → 요청 시점엔 큐에 있던 요청까지는 중복으로 인식 못하기 때문에

3. **실패 요청 처리**

    * 처리 중 예외가 발생하거나, 시스템 문제로 DB 저장이 실패하면 Redis의 **실패 요청 큐**에 따로 적재
    * 재시도 가능한 구조로 설계해서 **최종 일관성 보장**을 시도

---

## 4. 비동기 구조에서의 사용자 응답 처리

이 구조는 **비동기 처리**를 기반으로 하기 때문에, 발급 요청을 받은 즉시 처리 결과를 줄 수 없습니다. 그래서 **사용자는 발급 여부를 polling 방식으로 확인**해야 했습니다.

하지만 이 방식에도 몇 가지 아쉬운 점이 있었습니다.

* polling 간격이나 배치 간격에 따라 **사용자가 실제 발급에 성공했는데 실패 응답을 받을 수 있는 시점 차이 문제가 존재**
* 예를 들어, 연속해서 두 번 요청을 보냈을 때 첫 번째는 성공하고 두 번째는 중복 실패했지만, 두 번째 결과만 보고 실패로 착각할 수 있음

### 개선 아이디어

* 발급 상태 조회 시, **단순 성공/실패가 아니라, 실제 발급된 쿠폰 정보까지 응답하도록** 개선
* 동일 유저의 요청에 대해서는 **항상 동일한 응답을 보장**하는 방식 도입 고려

---

## 5. Redis 기반 구조의 한계와 고민

Redis를 활용한 구조는 확실히 성능과 처리량 측면에서는 큰 장점이 있었지만, 동시에 Redis의 특성과 한계 때문에 몇 가지 고민이 생겼습니다.

* Redis는 트랜잭션 보장이 약하고, 장애 시 복구가 어렵기 때문에 **신뢰성 있는 데이터 저장소로 쓰기엔 부담이 큼**
* 쿠폰 발급은 **실패 없이 안정적으로 처리되어야 하는 민감한 도메인**이기 때문에, Redis를 중심으로 모든 처리를 구성하는 것이 맞는가에 대한 의문
* Redis에 너무 많은 로직이 들어가다 보니 **Lua 스크립트가 길어지고 유지보수 난이도가 올라감**

결국 Redis는 DB를 대체하기보다는, **DB의 병목을 줄이기 위한 선처리 도구(필터 + 큐)의 역할로 한정하는 것이 더 적절**하다는 결론에 도달했습니다.

---

## 6. 마무리 및 느낀 점

이번 과제를 통해 Redis를 활용한 고성능 설계를 직접 시도해볼 수 있었고, 단순히 "빠르다"는 이유로 모든 걸 Redis로 처리하려다 보면 **정합성과 복잡도 측면에서 오히려 위험해질 수 있다는 점**을 체감할 수 있었습니다.

개인적으로 가장 의미 있었던 부분은 **성능과 안정성 사이의 균형**을 어떻게 잡을지 고민했던 과정이었습니다.
추후 개선이 필요한 부분으로는 다음과 같은 것들을 고려하고 있습니다.

* polling 방식 외에 **SSE, Webhook 등 실시간 응답 구조** 검토
* Redis 키 TTL 관리 및 메모리 누수 방지를 위한 최적화
* 실패 큐의 재처리 기준 및 반복 실패에 대한 fallback 정책 마련

실무에서는 Redis뿐만 아니라 Kafka나 SQS 같은 **메시징 시스템도 함께 활용**하는 방식으로 구조를 더 견고하게 만들 수 있을 것 같다는 생각도 들었습니다.
이번 설계를 기반으로, 다양한 시나리오에 맞는 분산 시스템 설계에 대한 감각을 더 키워가고 싶습니다.

