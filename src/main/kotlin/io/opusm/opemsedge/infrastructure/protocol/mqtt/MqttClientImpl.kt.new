package io.opusm.opemsedge.infrastructure.protocol.mqtt

import io.opusm.opemsedge.core.device.model.Device
import io.opusm.opemsedge.core.device.model.ProtocolType
import io.opusm.opemsedge.core.protocol.model.CommandResult
import io.opusm.opemsedge.core.protocol.model.CommandType
import io.opusm.opemsedge.core.protocol.model.DeviceCommand
import io.opusm.opemsedge.core.protocol.model.ProtocolResult
import io.opusm.opemsedge.core.protocol.port.ProtocolClient
import io.opusm.opemsedge.infrastructure.protocol.mqtt.command.MqttCommandStrategyFactory
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * MQTT 프로토콜 클라이언트 구현 클래스
 * 장치와의 MQTT 통신 및 외부 시스템과의 MQTT 통신을 처리합니다.
 */
@Component
class MqttClientImpl(
    private val connectionManager: MqttConnectionManager,
    private val messageManager: MqttMessageManager,
    private val commandStrategyFactory: MqttCommandStrategyFactory
) : ProtocolClient {

    private val logger = LoggerFactory.getLogger(MqttClientImpl::class.java)

    override suspend fun connect(device: Device): ProtocolResult<Boolean> {
        return withContext(Dispatchers.IO) {
            try {
                val result = connectionManager.connect(device)
                
                if (result.success && result.data == true) {
                    // 메시지 큐 초기화
                    messageManager.initializeMessageQueue(device.id)
                    
                    // 클라이언트 콜백 설정
                    val client = connectionManager.getClient(device.id)
                    if (client != null) {
                        messageManager.setupCallback(device.id, client)
                        
                        // 토픽 구독
                        connectionManager.subscribeToDeviceTopics(device, client)
                    }
                }
                
                result
            } catch (e: Exception) {
                logger.error("MQTT 연결 실패: ${device.id}", e)
                ProtocolResult.failure("MQTT 연결 실패: ${e.message}")
            }
        }
    }

    override suspend fun disconnect(device: Device): ProtocolResult<Boolean> {
        return withContext(Dispatchers.IO) {
            try {
                // 메시지 큐 제거
                messageManager.removeMessageQueue(device.id)
                
                // 연결 해제
                connectionManager.disconnect(device)
            } catch (e: Exception) {
                logger.error("MQTT 연결 해제 실패: ${device.id}", e)
                ProtocolResult.failure("MQTT 연결 해제 실패: ${e.message}")
            }
        }
    }

    override suspend fun isConnected(deviceId: String): Boolean {
        return connectionManager.isConnected(deviceId)
    }

    override suspend fun executeCommand(device: Device, command: DeviceCommand): CommandResult {
        return withContext(Dispatchers.IO) {
            if (!isConnected(device.id)) {
                return@withContext CommandResult(
                    deviceId = device.id,
                    commandType = command.commandType,
                    success = false,
                    error = "장치가 연결되어 있지 않습니다"
                )
            }

            val strategy = commandStrategyFactory.getStrategy(command.commandType)
            if (strategy == null) {
                return@withContext CommandResult(
                    deviceId = device.id,
                    commandType = command.commandType,
                    success = false,
                    error = "지원되지 않는 명령: ${command.commandType}"
                )
            }

            try {
                strategy.execute(device, command, messageManager)
            } catch (e: Exception) {
                logger.error("명령 실행 중 오류 발생: ${device.id}, ${command.commandType}", e)
                CommandResult(
                    deviceId = device.id,
                    commandType = command.commandType,
                    success = false,
                    error = "명령 실행 중 오류 발생: ${e.message}"
                )
            }
        }
    }

    override fun getSupportedCommands(): Set<CommandType> {
        return commandStrategyFactory.getSupportedCommandTypes()
    }

    override fun getSupportedProtocol(): List<ProtocolType> = listOf(ProtocolType.MQTT)
}